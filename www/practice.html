<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>bitmania</title>
  <style>
    .custom-input{width: 50px;}
    body{ 
       font-family: Arial
       ,sans-serif;
       background-color: #EEE;
    }
    #pTempoMark{
       font-size: 30px;

    }
  </style>

</head>
<body>
  <h1>PRACTICE</h1>
  <label for="txtBpm">bpm:</label>
  <input type="text" id="txtBpm" name="txtBpm" value="60" class="custom-input" >
  <select id="cmbScore" name="score">
    <option>01_8beat.txt</option>
    <option>02_8beat.txt</option>
    <option>03_8beat.txt</option>
    <option>04_8beat.txt</option>
  </select>
  <input type="button" value="START" onclick="start()" >
 
  <p id="pTempoMark">----</p>

  <canvas id="cvs" width="300px" height="500px"></canvas>
  <audio id="mainClickSound" preload="auto"><source src="./music/05_hihat_ti.mp3" type="audio/mp3" muted controls></audio>
  <audio id="subClickSound" preload="auto"><source src="./music/99_hihat_tito.mp3" type="audio/mp3" muted controls></audio>
  <script>
    let tempoText;
    let beforeUpdateId = null;

    const NOTES_WIDTH = 30;
    let isDownInputKey1 =false;
    let isDownInputKey2 =false;
    let isDownInputKey3 =false;
    let isDownInputKey4 =false;
    let isDownInputKey5 =false;
    let isDownInputKey6 =false;
    let isDownInputKey7 =false;
    let isDownInputKey8 =false;

    function playSound(sound){
      sound.currentTime = 0;
      let promise = sound.play();
      if (promise !== undefined) {
        promise.then(_ => {
          //console.log("ok");
        }).catch(error => {
          console.log("promise error");
        });
      }
   }
    function pageLoad(loadFileName){
      drawFrame();
      setTempoText();
      setVolume();
      function setTempoText(){
        xhr = new XMLHttpRequest();
        xhr.open('GET', "./score/" + loadFileName, true);
         xhr.onreadystatechange = function () {
            if (xhr.readyState == 4 && xhr.status == 200) {
              loadText = xhr.responseText;
              tempoText = loadText.split("\n");
            }
        };
        xhr.send();
      }
      function setVolume(){
        mainClickSound.volume=0.5;
     }
    }
    function drawFrame(){
      const canvas = document.getElementById("cvs");
      const ctx = canvas.getContext("2d");

      ctx.fillStyle = "black";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      ctx.fillStyle = "black";
      ctx.fillRect(24,29,241,421);
      ctx.strokeStyle = "grey"
      ctx.lineWidth = 0.5;
      ctx.strokeRect(25,30,240,420);

      for(let i = 1; i<8; i++){
        ctx.beginPath();
        ctx.moveTo(25+NOTES_WIDTH*i,30+420);
        ctx.lineTo(25+NOTES_WIDTH*i,30);
        ctx.stroke();
      }
    }
    function start(){

      // 選択されたテキストを取得
      const selectElement = document.getElementById("cmbScore");
      const selectedText = selectElement.options[selectElement.selectedIndex].text;
      pageLoad(selectedText);

      document.addEventListener('keydown', keydown_event);
      document.addEventListener('keyup', keyup_event);

      let startTime = Date.now();
      let secBaseClick = 60/txtBpm.value;     
      let countClick = 0;
      let countTempo = 0;

      let notes1 = [];
      let notes2 = [];
      let notes3 = [];
      let notes4 = [];
      let notes5 = [];
      let notes6 = [];
      let notes7 = [];
      let notes8 = [];

      const canvas = document.getElementById("cvs");
      const ctx = canvas.getContext("2d");

      let score = 0;
      let result = "";
      let milliSecDiff = "±milliSecond";

      if(update != null){
        window.cancelAnimationFrame(beforeUpdateId);
      }
      
      update(); 
      function update(){
        let elaspsedTime = Date.now() - startTime; 
        if(elaspsedTime/1000 > countClick * secBaseClick){

          tempoText.forEach((dataRow) => {
            if(dataRow != ""){
              tempo = dataRow.substring(countClick,countClick+1);
              //tempoFlg = true;
              switch (tempo){
                case "1":notes1.push(Date.now());break;
                case "2":notes2.push(Date.now());break;
                case "3":notes3.push(Date.now());break;
                case "5":notes5.push(Date.now());break;
                case "6":notes6.push(Date.now());break;
                case "7":notes7.push(Date.now());break;
                case "8":notes8.push(Date.now());break;
              }
            }
          });

          countTempo++;
          countClick++; 

          playSound(subClickSound);
     
          let workTempo = ""
          for(let i=0; i<countTempo; i++){
            workTempo = workTempo + "*"; 
          } 
          pTempoMark.textContent = workTempo;
          if(countTempo === 4){
            countTempo = 0;
          }
        }
        //delete notes
        ctx.fillStyle = "black";
        ctx.fillRect(25,30,420,419);

        drawFrame();
        //input key
        const notesWidth = 30;
        ctx.lineWidth = 1;

        ctx.strokeStyle = "red";
        ctx.strokeRect(30+notesWidth*0,450,20,40);
        if(isDownInputKey1){
          ctx.fillStyle = "red";
          ctx.fillRect(30+30*0,450,20,40);
        }

        ctx.strokeStyle = "white";
        ctx.strokeRect(30+notesWidth*1,450,20,40);
        if(isDownInputKey2){
          ctx.fillStyle = "white";
          ctx.fillRect(30+30*1,450,20,40);
        }

        ctx.strokeStyle = "blue";
        ctx.strokeRect(30+notesWidth*2,450,20,40);
        if(isDownInputKey3){
          ctx.fillStyle = "blue";
          ctx.fillRect(30+30*2,450,20,40);
        }

        ctx.strokeStyle = "white";
        ctx.strokeRect(30+notesWidth*3,450,20,40);
        if(isDownInputKey4){
          ctx.fillStyle = "white";
          ctx.fillRect(30+30*3,450,20,40);
        }

        ctx.strokeStyle = "blue";
        ctx.strokeRect(30+notesWidth*4,450,20,40);
        if(isDownInputKey5){
          ctx.fillStyle = "blue";
          ctx.fillRect(30+30*4,450,20,40);
        }

        ctx.strokeStyle = "white";
        ctx.strokeRect(30+notesWidth*5,450,20,40);
        if(isDownInputKey6){
          ctx.fillStyle = "white";
          ctx.fillRect(30+30*5,450,20,40);
        }

        ctx.strokeStyle = "blue";
        ctx.strokeRect(30+notesWidth*6,450,20,40);
        if(isDownInputKey7){
          ctx.fillStyle = "blue";
          ctx.fillRect(30+30*6,450,20,40);
        }

        ctx.strokeStyle = "white";
        ctx.strokeRect(30+notesWidth*7,450,20,40);
        if(isDownInputKey8){
          ctx.fillStyle = "white";
          ctx.fillRect(30+30*7,450,20,40);
        }

        //draw notes
        drawNotes(notes1,1);
        drawNotes(notes2,2);
        drawNotes(notes3,3);
        drawNotes(notes4,4);
        drawNotes(notes5,5);
        drawNotes(notes6,6);
        drawNotes(notes7,7);
        drawNotes(notes8,8);

        beforeUpdateId = requestAnimationFrame(update);
      }

      function keydown_event(e){

        console.log(e)

        if(e.key === "Shift"){
          isDownInputKey1=true;
        }
        if(e.keyCode === 32){
          e.preventDefault();
        }

        switch (e.key.toLowerCase()){
          case "z":
            isDownInputKey2=true;
            break;

          case "x":
            isDownInputKey3=true;
            break;

          case "c":
            isDownInputKey4=true;
            break;

          case " ":
            isDownInputKey5=true;
            break;

          case "j":
            isDownInputKey6=true;
            break;

          case "k":
            isDownInputKey7=true;
            break;

          case "l":
            isDownInputKey8=true;
            break;
        }
      }
      function keyup_event(e){
        switch (e.key.toLowerCase()){
          case "shift":
           isDownInputKey1=false;
           break;
         
          case "z":
            isDownInputKey2=false;
            break;

          case "x":
            isDownInputKey3=false;
            break;

          case "c":
            isDownInputKey4=false;
            break;

          case " ": 
            isDownInputKey5=false;
            break;

          case "j": 
            isDownInputKey6=false;
            break;
          
          case "k": 
            isDownInputKey7=false;
            break;
          
          case "l": 
            isDownInputKey8=false;
            break;
          }
      }
      function drawNotes(notes,index){
        notes.forEach((n) => {
          let notesPos=(Date.now()-n)/1000*105;
          if(notesPos >= 415){
            // 入力キーを上書きしてしまうため何もしない 
          }else{ 
            ctx.beginPath();
            ctx.lineWidth = 2; 
            ctx.moveTo(25+NOTES_WIDTH*(index-1),32+notesPos);
            ctx.lineTo(25+NOTES_WIDTH*(index-1)+NOTES_WIDTH,32+notesPos);

            switch (index){
              case 1:
                ctx.strokeStyle = "red";
                break;
              case 2:
              case 4:
              case 6:
              case 8:
                ctx.strokeStyle = "white";
                break;
              case 3:
              case 5:
              case 7:
                ctx.strokeStyle = "blue";
                break;
            }
            ctx.stroke();
          }
        });
      }
   } 
 </script>

</body>

